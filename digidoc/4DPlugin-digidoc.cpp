/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-digidoc.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : digidoc
 #	author : miyako
 #	2020/10/23
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-digidoc.h"

#pragma mark -

using namespace std;

namespace std
{

/*
static ostream &operator<<(ostream &os, const X509Cert &cert)
{
    return os << cert.subjectName("CN");
}*/

/*
static ostream &operator<<(ostream &os, const vector<unsigned char> &data)
{
    os << hex << uppercase << setfill('0');
    for(const unsigned char &i: data)
        os << setw(2) << static_cast<int>(i) << ' ';
    return os << dec << nouppercase << setfill(' ');
}*/

static ostream &operator<<(ostream &os, const Exception::ExceptionCode code)
{
    switch(code)
    {
        case Exception::General: os << "General"; break;
        case Exception::CertificateIssuerMissing: os << "CertificateIssuerMissing"; break;
        case Exception::CertificateRevoked: os << "CertificateRevoked"; break;
        case Exception::CertificateUnknown: os << "CertificateUnknown"; break;
        case Exception::OCSPResponderMissing: os << "OCSPResponderMissing"; break;
        case Exception::OCSPCertMissing: os << "OCSPCertMissing"; break;
        case Exception::OCSPTimeSlot: os << "OCSPTimeSlot"; break;
        case Exception::OCSPRequestUnauthorized: os << "OCSPRequestUnauthorized"; break;
        case Exception::PINCanceled: os << "PINCanceled"; break;
        case Exception::PINFailed: os << "PINFailed"; break;
        case Exception::PINIncorrect: os << "PINIncorrect"; break;
        case Exception::PINLocked: os << "PINLocked"; break;
        case Exception::ReferenceDigestWeak: os << "ReferenceDigestWeak"; break;
        case Exception::SignatureDigestWeak: os << "SignatureDigestWeak"; break;
        case Exception::DataFileNameSpaceWarning: os << "DataFileNameSpaceWarning"; break;
        case Exception::IssuerNameSpaceWarning: os << "IssuerNameSpaceWarning"; break;
        case Exception::ProducedATLateWarning: os << "ProducedATLateWarning"; break;
        case Exception::MimeTypeWarning: os << "MimeTypeWarning"; break;
        default: os << code;
    }
    return os;
}

static ostream &operator<<(ostream &os, const Exception &e)
{
    os << e.file() << ":" << e.line() << " code(" << e.code() << ") " << e.msg() << endl;
    for(const Exception &ex: e.causes())
        os << ex;
    return os;
}
}

class ToolConfig: public XmlConfCurrent
{
public:

    ToolConfig();
    static ToolConfig* instance();
    int logLevel() const override { return _logLevel; }
    string logFile() const override { return _logFile; }
    string digestUri() const override { return uri; }
    string signatureDigestUri() const override { return siguri; }
    bool TSLAllowExpired() const override { return expired; }
    vector<X509Cert> TSLCerts() const override { return tslcerts; }
    string TSUrl() const override { return tsurl; }
    string TSLUrl() const override { return tslurl; }
    string TSLCache() const override { return tslcache; }
    
    unique_ptr<Signer> getSigner(bool getwebsigner = false) const;

    // Config
    int _logLevel;
    bool expired = false;
    vector<X509Cert> tslcerts;
    string _logFile, tsurl, tslurl, uri, siguri;

    // Params
    string path, profile, pkcs11, pkcs12, pin, city, street, state, postalCode, country, cert, tslcache;
    vector<unsigned char> thumbprint;
    vector<pair<string,string> > files;
    vector<string> roles;
    bool cng = true, selectFirst = false, doSign = true, dontValidate = false, XAdESEN = false;
    static const map<string,string> profiles;
};

ToolConfig::ToolConfig()
: _logLevel(XmlConfCurrent::logLevel())
, expired(XmlConfCurrent::TSLAllowExpired())
, tslcerts(XmlConfCurrent::TSLCerts())
, _logFile(XmlConfCurrent::logFile())
, tsurl(XmlConfCurrent::TSUrl())
, tslurl(XmlConfCurrent::TSLUrl())
, uri(XmlConfCurrent::digestUri())
, siguri(XmlConfCurrent::signatureDigestUri())
{
    
}

ToolConfig* ToolConfig::instance() { return dynamic_cast<ToolConfig*>(Conf::instance()); }

/*
class ConsolePinSigner : public PKCS11Signer
{
public:
    ConsolePinSigner(const string &driver, const string &pin): PKCS11Signer(driver)
    {
        setPin(pin);
    }

private:
    string pin(const X509Cert &certificate) const override;
    X509Cert selectSigningCertificate(const vector<X509Cert> &certificates) const override
    {
        cout << "Available certificates:" << endl;
        for(const X509Cert &cert: certificates)
            cout << "  label: " << cert << endl;
        cout << "Selected:" << endl;
        X509Cert cert = certificates.front();
        cout << "  label: " << cert << endl;
        return cert;
    }
};

string ConsolePinSigner::pin(const X509Cert &certificate) const
{
    if(!PKCS11Signer::pin(certificate).empty())
        return PKCS11Signer::pin(certificate);

    char pin[16];
    size_t pinMax = 16;

    const char *prompt = "Please enter PIN for token '%s' or <enter> to cancel: ";
#if defined(_WIN32)
    // something that acts wildly similarily with getpass()
    {
        printf(prompt, certificate.subjectName("CN").c_str());
        size_t i = 0;
        int c;
        while ( (c = _getch()) != '\r' )
        {
            switch ( c )
            {
            default:
                if ( i >= pinMax-1 || iscntrl( c ) )
                {
                    // can't be a part of password
                    fputc( '\a', stdout );
                    break;
                }
                pin[i++] = static_cast<char>(c);
                fputc( '*', stdout );
                break;
            case EOF:
            {
                fputs( "[EOF]\n", stdout );
                Exception e(EXCEPTION_PARAMS("PIN acquisition canceled with [EOF]."));
                e.setCode( Exception::PINCanceled );
                throw e;
            }
            case 0:
            case 0xE0:  // FN Keys (0 or E0) start of two-character FN code
                c = ( c << 4 ) | _getch();
                if ( c != 0xE53 && c != 0xE4B && c != 0x053 && c != 0x04b )
                {
                    // not {DELETE}, {<--}, Num{DEL} and Num{<--}
                    fputc( '\a', stdout );
                    break;
                }
                // NO BREAK, fall through to the one-character deletes
            case '\b':
            case 127:
                if ( i == 0 )
                {
                    // nothing to delete
                    fputc( '\a', stdout );
                    break;
                }
                pin[--i] = '\0';
                fputs( "\b \b", stdout );
                break;
            case  3: // CTRL+C
            {
                fputs( "^C\n", stdout );
                Exception e(EXCEPTION_PARAMS("PIN acquisition canceled with ^C."));
                e.setCode( Exception::PINCanceled );
                throw e;
            }
            case  26: // CTRL+Z
            {
                fputs( "^Z\n", stdout );
                Exception e(EXCEPTION_PARAMS("PIN acquisition canceled with ^Z."));
                e.setCode( Exception::PINCanceled );
                throw e;
            }
            case  27: // ESC
                fputc('\n', stdout );
                printf(prompt, certificate.subjectName("CN").c_str());
                i = 0;
                break;
            }
        }
        fputc( '\n', stdout );
        pin[i] = '\0';
    }
#else
    char* pwd = getpass(Log::format(prompt, certificate.subjectName("CN").c_str()).c_str());
    strncpy(pin, pwd, pinMax);
#endif

    pin[pinMax-1] = '\0';

    string result(pin);
    if(result.empty())
    {
        Exception e(EXCEPTION_PARAMS("PIN acquisition canceled."));
        e.setCode( Exception::PINCanceled );
        throw e;
    }

    return result;
}
*/
unique_ptr<Signer> ToolConfig::getSigner(bool getwebsigner) const
{
    unique_ptr<Signer> signer;
    if(getwebsigner)
    {
        class WebSigner: public Signer
        {
        public:
            WebSigner(X509Cert cert): _cert(move(cert)) {}
            X509Cert cert() const override { return _cert; }
            vector<unsigned char> sign(const string & /*method*/, const vector<unsigned char> & /*digest*/) const override
            {
                THROW("Not implemented");
            }
            X509Cert _cert;
        };
        signer.reset(new WebSigner(X509Cert(cert, X509Cert::Pem)));
    }
#ifdef _WIN32
    else if(cng)
    {
        WinSigner *win = new WinSigner(pin, selectFirst);
        win->setThumbprint(thumbprint);
        signer.reset(win);
    }
    else
#endif
        if(!pkcs12.empty()){
            signer.reset(new PKCS12Signer(pkcs12, pin));
        }   else{
//        signer.reset(new ConsolePinSigner(pkcs11, pin));
        }
    signer->setENProfile(XAdESEN);
    signer->setSignatureProductionPlaceV2(city, street, state, postalCode, country);
    signer->setSignerRoles(roles);
    signer->setProfile(profile);
    return signer;
}

static void OnStartup() {
        
    //load default xml conf
    ToolConfig *conf = new ToolConfig();
                
    conf->tslcerts = {
        X509Cert("/Users/miyako/Desktop/digidoc/test/Resources/cert.pem"),
        X509Cert("/Users/miyako/Desktop/digidoc/test/Resources/trusted-test-tsl.crt")
    };
        
    //this file is downloaded to tlscache
    conf->tslurl = "https://open-eid.github.io/test-TL/tl-mp-test-EE.xml";
        
    conf->dontValidate = true;
    conf->tslcache = "/Users/miyako/Desktop/cache";
    
    //use xml conf to init conf
    digidoc::Conf::init(conf);
    
    //init library with conf
    digidoc::initialize();
    
    std::cout << "appInfo:"   << digidoc::appInfo()   << std::endl;
    std::cout << "userAgent:" << digidoc::userAgent() << std::endl;
    std::cout << "version:"   << digidoc::version()   << std::endl;

}

static void OnExit() {
    digidoc::terminate();
}

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
            case kInitPlugin :
            case kServerInitPlugin :
                OnStartup();
                break;
                
            case kDeinitPlugin :
            case kServerDeinitPlugin :
                OnExit();
                break;
                
			// --- digidoc
            
			case 1 :
				digidoc_sign(params);
				break;
			case 2 :
				digidoc_verify(params);
				break;

        }

	}
	catch(...)
	{

	}
}

#pragma mark -

using namespace digidoc;

void digidoc_sign(PA_PluginParameters params) {

    try
    {
        ToolConfig *xmlConf = ToolConfig::instance();
        
//        xmlConf->setTSUrl("https://freetsa.org/tsr");
        std::string tsUrl = xmlConf->TSUrl();
                
        std::vector<X509Cert> certs = xmlConf->TSLCerts();
                         
        xmlConf->pkcs12 = "/Users/miyako/Desktop/digidoc/test/Resources/certificate.pfx";
        xmlConf->pin = "4d4d4d";
        
        unique_ptr<Signer> signer = xmlConf->getSigner();
        
        std::string profile = "time-stamp"; // "time-mark" or "time-stamp"
        signer->setProfile(profile);
           
        std::string method = signer->method();//"http://www.w3.org/2001/04/xmlenc#sha256"

        std::unique_ptr<Container> doc(Container::createPtr("/Users/miyako/Desktop/test.bdoc"));
        
        doc->addDataFile("/Users/miyako/Desktop/TODAY.txt", "application/octet-stream");
        
        Signature *signature = doc->sign(signer.get());

        doc->save();

    }
    catch(const Exception &e)
    {
        std::cout << e;
    }
 
}

void digidoc_verify(PA_PluginParameters params) {

}

